/*
 * Firebase Cloud Messaging
 * Send downstream messages to client apps
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package eu.aily.external.fcm;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import eu.aily.external.fcm.Notification;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Message
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2017-09-12T12:02:11.741+02:00")
public class Message {
  @SerializedName("to")
  private String to = null;

  @SerializedName("registration_ids")
  private List<String> registrationIds = null;

  @SerializedName("condition")
  private String condition = null;

  @SerializedName("notification_key")
  private String notificationKey = null;

  @SerializedName("collapse_key")
  private String collapseKey = null;

  /**
   * Sets the priority of the message. Valid values are normal and high. On iOS, these correspond to APNs priorities 5 and 10. By default, messages are sent with normal priority. Normal priority optimizes the client app&#39;s battery consumption and should be used unless immediate delivery is required. For messages with normal priority, the app may receive the message with unspecified delay. When a message is sent with high priority, it is sent immediately, and the app can wake a sleeping device and open a network connection to your server.For more information, see [Setting the priority of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#setting-the-priority-of-a-message). 
   */
  @JsonAdapter(PriorityEnum.Adapter.class)
  public enum PriorityEnum {
    NORMAL("normal"),
    
    HIGH("high");

    private String value;

    PriorityEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PriorityEnum fromValue(String text) {
      for (PriorityEnum b : PriorityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PriorityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PriorityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PriorityEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PriorityEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("priority")
  private PriorityEnum priority = null;

  @SerializedName("content_available")
  private Boolean contentAvailable = null;

  @SerializedName("mutable_content")
  private Boolean mutableContent = null;

  @SerializedName("delay_while_idle")
  private Boolean delayWhileIdle = null;

  @SerializedName("time_to_live")
  private BigDecimal timeToLive = null;

  @SerializedName("restricted_package_name")
  private String restrictedPackageName = null;

  @SerializedName("dry_run")
  private Boolean dryRun = null;

  @SerializedName("data")
  private Map<String, String> data = null;

  @SerializedName("notification")
  private Notification notification = null;

  public Message to(String to) {
    this.to = to;
    return this;
  }

   /**
   * This parameter specifies the recipient of a message. The value must be a registration token, notification key, or topic. Do not set this field when sending to multiple topics. See **condition**. 
   * @return to
  **/
  @ApiModelProperty(value = "This parameter specifies the recipient of a message. The value must be a registration token, notification key, or topic. Do not set this field when sending to multiple topics. See **condition**. ")
  public String getTo() {
    return to;
  }

  public void setTo(String to) {
    this.to = to;
  }

  public Message registrationIds(List<String> registrationIds) {
    this.registrationIds = registrationIds;
    return this;
  }

  public Message addRegistrationIdsItem(String registrationIdsItem) {
    if (this.registrationIds == null) {
      this.registrationIds = new ArrayList<String>();
    }
    this.registrationIds.add(registrationIdsItem);
    return this;
  }

   /**
   * This parameter specifies a list of devices (registration tokens, or IDs) receiving a multicast message. It must contain at least 1 and at most 1000 registration tokens. Use this parameter only for multicast messaging, not for single recipients. Multicast messages (sending to more than 1 registration tokens) are allowed using HTTP JSON format only. 
   * @return registrationIds
  **/
  @ApiModelProperty(value = "This parameter specifies a list of devices (registration tokens, or IDs) receiving a multicast message. It must contain at least 1 and at most 1000 registration tokens. Use this parameter only for multicast messaging, not for single recipients. Multicast messages (sending to more than 1 registration tokens) are allowed using HTTP JSON format only. ")
  public List<String> getRegistrationIds() {
    return registrationIds;
  }

  public void setRegistrationIds(List<String> registrationIds) {
    this.registrationIds = registrationIds;
  }

  public Message condition(String condition) {
    this.condition = condition;
    return this;
  }

   /**
   * This parameter specifies a logical expression of conditions that determine the message target. Supported condition: Topic, formatted as yourTopic in topics. This value is case-insensitive. Supported operators: &amp;&amp;, ||. Maximum two operators per topic message supported. 
   * @return condition
  **/
  @ApiModelProperty(value = "This parameter specifies a logical expression of conditions that determine the message target. Supported condition: Topic, formatted as yourTopic in topics. This value is case-insensitive. Supported operators: &&, ||. Maximum two operators per topic message supported. ")
  public String getCondition() {
    return condition;
  }

  public void setCondition(String condition) {
    this.condition = condition;
  }

  public Message notificationKey(String notificationKey) {
    this.notificationKey = notificationKey;
    return this;
  }

   /**
   * This parameter is deprecated. Instead, use **to** to specify message recipients. For more information on how to send messages to multiple devices using **to**, see [Device Group Messaging](https://firebase.google.com/docs/cloud-messaging/notifications). 
   * @return notificationKey
  **/
  @ApiModelProperty(value = "This parameter is deprecated. Instead, use **to** to specify message recipients. For more information on how to send messages to multiple devices using **to**, see [Device Group Messaging](https://firebase.google.com/docs/cloud-messaging/notifications). ")
  public String getNotificationKey() {
    return notificationKey;
  }

  public void setNotificationKey(String notificationKey) {
    this.notificationKey = notificationKey;
  }

  public Message collapseKey(String collapseKey) {
    this.collapseKey = collapseKey;
    return this;
  }

   /**
   * This parameter identifies a group of messages (e.g., with &#x60;&#x60;&#x60;\&quot;collapse_key\&quot;: \&quot;Updates Available\&quot;&#x60;&#x60;&#x60;) that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active (see **delay_while_idle**). Note that there is no guarantee of the order in which messages get sent. Note: A maximum of 4 different collapse keys is allowed at any given time. This means a FCM connection server can simultaneously store 4 different send-to-sync messages per client app. If you exceed this number, there is no guarantee which 4 collapse keys the FCM connection server will keep. 
   * @return collapseKey
  **/
  @ApiModelProperty(value = "This parameter identifies a group of messages (e.g., with ```\"collapse_key\": \"Updates Available\"```) that can be collapsed, so that only the last message gets sent when delivery can be resumed. This is intended to avoid sending too many of the same messages when the device comes back online or becomes active (see **delay_while_idle**). Note that there is no guarantee of the order in which messages get sent. Note: A maximum of 4 different collapse keys is allowed at any given time. This means a FCM connection server can simultaneously store 4 different send-to-sync messages per client app. If you exceed this number, there is no guarantee which 4 collapse keys the FCM connection server will keep. ")
  public String getCollapseKey() {
    return collapseKey;
  }

  public void setCollapseKey(String collapseKey) {
    this.collapseKey = collapseKey;
  }

  public Message priority(PriorityEnum priority) {
    this.priority = priority;
    return this;
  }

   /**
   * Sets the priority of the message. Valid values are normal and high. On iOS, these correspond to APNs priorities 5 and 10. By default, messages are sent with normal priority. Normal priority optimizes the client app&#39;s battery consumption and should be used unless immediate delivery is required. For messages with normal priority, the app may receive the message with unspecified delay. When a message is sent with high priority, it is sent immediately, and the app can wake a sleeping device and open a network connection to your server.For more information, see [Setting the priority of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#setting-the-priority-of-a-message). 
   * @return priority
  **/
  @ApiModelProperty(value = "Sets the priority of the message. Valid values are normal and high. On iOS, these correspond to APNs priorities 5 and 10. By default, messages are sent with normal priority. Normal priority optimizes the client app's battery consumption and should be used unless immediate delivery is required. For messages with normal priority, the app may receive the message with unspecified delay. When a message is sent with high priority, it is sent immediately, and the app can wake a sleeping device and open a network connection to your server.For more information, see [Setting the priority of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#setting-the-priority-of-a-message). ")
  public PriorityEnum getPriority() {
    return priority;
  }

  public void setPriority(PriorityEnum priority) {
    this.priority = priority;
  }

  public Message contentAvailable(Boolean contentAvailable) {
    this.contentAvailable = contentAvailable;
    return this;
  }

   /**
   * On iOS, use this field to represent **content-available** in the APNS payload. When a notification or message is sent and this is set to &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60;, an inactive client app is awoken. On Android, data messages wake the app by default. On Chrome, currently not supported. 
   * @return contentAvailable
  **/
  @ApiModelProperty(value = "On iOS, use this field to represent **content-available** in the APNS payload. When a notification or message is sent and this is set to ```true```, an inactive client app is awoken. On Android, data messages wake the app by default. On Chrome, currently not supported. ")
  public Boolean getContentAvailable() {
    return contentAvailable;
  }

  public void setContentAvailable(Boolean contentAvailable) {
    this.contentAvailable = contentAvailable;
  }

  public Message mutableContent(Boolean mutableContent) {
    this.mutableContent = mutableContent;
    return this;
  }

   /**
   * Currently for iOS 10+ devices only. On iOS, use this field to represent mutable-content in the APNS payload. When a notification is sent and this is set to true, the content of the notification can be modified before it is displayed, using a [Notification Service app extension](https://developer.apple.com/reference/usernotifications/unnotificationserviceextension). This parameter will be ignored for Android and web. 
   * @return mutableContent
  **/
  @ApiModelProperty(value = "Currently for iOS 10+ devices only. On iOS, use this field to represent mutable-content in the APNS payload. When a notification is sent and this is set to true, the content of the notification can be modified before it is displayed, using a [Notification Service app extension](https://developer.apple.com/reference/usernotifications/unnotificationserviceextension). This parameter will be ignored for Android and web. ")
  public Boolean getMutableContent() {
    return mutableContent;
  }

  public void setMutableContent(Boolean mutableContent) {
    this.mutableContent = mutableContent;
  }

  public Message delayWhileIdle(Boolean delayWhileIdle) {
    this.delayWhileIdle = delayWhileIdle;
    return this;
  }

   /**
   * When this parameter is set to &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60;, it indicates that the message should not be sent until the device becomes active. The default value is &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60;. 
   * @return delayWhileIdle
  **/
  @ApiModelProperty(value = "When this parameter is set to ```true```, it indicates that the message should not be sent until the device becomes active. The default value is ```false```. ")
  public Boolean getDelayWhileIdle() {
    return delayWhileIdle;
  }

  public void setDelayWhileIdle(Boolean delayWhileIdle) {
    this.delayWhileIdle = delayWhileIdle;
  }

  public Message timeToLive(BigDecimal timeToLive) {
    this.timeToLive = timeToLive;
    return this;
  }

   /**
   * This parameter specifies how long (in seconds) the message should be kept in FCM storage if the device is offline. The maximum time to live supported is 4 weeks, and the default value is 4 weeks. For more information, see [Setting the lifespan of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#ttl). 
   * @return timeToLive
  **/
  @ApiModelProperty(value = "This parameter specifies how long (in seconds) the message should be kept in FCM storage if the device is offline. The maximum time to live supported is 4 weeks, and the default value is 4 weeks. For more information, see [Setting the lifespan of a message](https://firebase.google.com/docs/cloud-messaging/concept-options#ttl). ")
  public BigDecimal getTimeToLive() {
    return timeToLive;
  }

  public void setTimeToLive(BigDecimal timeToLive) {
    this.timeToLive = timeToLive;
  }

  public Message restrictedPackageName(String restrictedPackageName) {
    this.restrictedPackageName = restrictedPackageName;
    return this;
  }

   /**
   * This parameter specifies the package name of the application where the registration tokens must match in order to receive the message. 
   * @return restrictedPackageName
  **/
  @ApiModelProperty(value = "This parameter specifies the package name of the application where the registration tokens must match in order to receive the message. ")
  public String getRestrictedPackageName() {
    return restrictedPackageName;
  }

  public void setRestrictedPackageName(String restrictedPackageName) {
    this.restrictedPackageName = restrictedPackageName;
  }

  public Message dryRun(Boolean dryRun) {
    this.dryRun = dryRun;
    return this;
  }

   /**
   * This parameter, when set to &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60;, allows developers to test a request without actually sending a message. The default value is &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60;. 
   * @return dryRun
  **/
  @ApiModelProperty(value = "This parameter, when set to ```true```, allows developers to test a request without actually sending a message. The default value is ```false```. ")
  public Boolean getDryRun() {
    return dryRun;
  }

  public void setDryRun(Boolean dryRun) {
    this.dryRun = dryRun;
  }

  public Message data(Map<String, String> data) {
    this.data = data;
    return this;
  }

  public Message putDataItem(String key, String dataItem) {
    if (this.data == null) {
      this.data = new HashMap<String, String>();
    }
    this.data.put(key, dataItem);
    return this;
  }

   /**
   * This parameter specifies the custom key-value pairs of the message&#39;s payload. For example, with &#x60;&#x60;&#x60;\&quot;data\&quot;:{\&quot;score\&quot;:\&quot;3x1\&quot;}&#x60;&#x60;&#x60;: On iOS, if the message is sent via APNS, it represents the custom data fields. If it is sent via FCM connection server, it would be represented as key value dictionary in &#x60;&#x60;&#x60;AppDelegate application:didReceiveRemoteNotification:&#x60;&#x60;&#x60;. On Android, this would result in an intent extra named **score** with the string value **3x1**. The key should not be a reserved word (\&quot;from\&quot; or any word starting with \&quot;google\&quot; or \&quot;gcm\&quot;). Do not use any of the words defined in this table (such as **collapse_key**). 
   * @return data
  **/
  @ApiModelProperty(value = "This parameter specifies the custom key-value pairs of the message's payload. For example, with ```\"data\":{\"score\":\"3x1\"}```: On iOS, if the message is sent via APNS, it represents the custom data fields. If it is sent via FCM connection server, it would be represented as key value dictionary in ```AppDelegate application:didReceiveRemoteNotification:```. On Android, this would result in an intent extra named **score** with the string value **3x1**. The key should not be a reserved word (\"from\" or any word starting with \"google\" or \"gcm\"). Do not use any of the words defined in this table (such as **collapse_key**). ")
  public Map<String, String> getData() {
    return data;
  }

  public void setData(Map<String, String> data) {
    this.data = data;
  }

  public Message notification(Notification notification) {
    this.notification = notification;
    return this;
  }

   /**
   * Get notification
   * @return notification
  **/
  @ApiModelProperty(value = "")
  public Notification getNotification() {
    return notification;
  }

  public void setNotification(Notification notification) {
    this.notification = notification;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Message message = (Message) o;
    return Objects.equals(this.to, message.to) &&
        Objects.equals(this.registrationIds, message.registrationIds) &&
        Objects.equals(this.condition, message.condition) &&
        Objects.equals(this.notificationKey, message.notificationKey) &&
        Objects.equals(this.collapseKey, message.collapseKey) &&
        Objects.equals(this.priority, message.priority) &&
        Objects.equals(this.contentAvailable, message.contentAvailable) &&
        Objects.equals(this.mutableContent, message.mutableContent) &&
        Objects.equals(this.delayWhileIdle, message.delayWhileIdle) &&
        Objects.equals(this.timeToLive, message.timeToLive) &&
        Objects.equals(this.restrictedPackageName, message.restrictedPackageName) &&
        Objects.equals(this.dryRun, message.dryRun) &&
        Objects.equals(this.data, message.data) &&
        Objects.equals(this.notification, message.notification);
  }

  @Override
  public int hashCode() {
    return Objects.hash(to, registrationIds, condition, notificationKey, collapseKey, priority, contentAvailable, mutableContent, delayWhileIdle, timeToLive, restrictedPackageName, dryRun, data, notification);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Message {\n");
    
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    registrationIds: ").append(toIndentedString(registrationIds)).append("\n");
    sb.append("    condition: ").append(toIndentedString(condition)).append("\n");
    sb.append("    notificationKey: ").append(toIndentedString(notificationKey)).append("\n");
    sb.append("    collapseKey: ").append(toIndentedString(collapseKey)).append("\n");
    sb.append("    priority: ").append(toIndentedString(priority)).append("\n");
    sb.append("    contentAvailable: ").append(toIndentedString(contentAvailable)).append("\n");
    sb.append("    mutableContent: ").append(toIndentedString(mutableContent)).append("\n");
    sb.append("    delayWhileIdle: ").append(toIndentedString(delayWhileIdle)).append("\n");
    sb.append("    timeToLive: ").append(toIndentedString(timeToLive)).append("\n");
    sb.append("    restrictedPackageName: ").append(toIndentedString(restrictedPackageName)).append("\n");
    sb.append("    dryRun: ").append(toIndentedString(dryRun)).append("\n");
    sb.append("    data: ").append(toIndentedString(data)).append("\n");
    sb.append("    notification: ").append(toIndentedString(notification)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

